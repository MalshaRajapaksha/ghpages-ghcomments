<div class="gpgc-all-comments gpgc-hidden" id="gpgc_all_comments">
</div>

<div class="gpgc-all-comments gpgc-hidden" id="gpgc_no_comments">
  <p class="gpgc-no-comments">No comments</p>
</div>

<div class="gpgc-actions gpgc-hidden" id="gpgc_actions">
  <span class="gpgc-action">
    <button class="gpgc-show" id="show_comments_button" onclick="showAllComments(CommentsArray)"></button>
  </span>
</div>

<div class="gpgc-all-comments">
  <div class="gpgc-comment">
    <a id="gpgc_reader_url" href="#"><img class="gpgc-avatar" id="gpgc_reader_avatar" src="{{ site.baseurl }}/public/apple-touch-icon-precomposed.png" height="42" /><span id="gpgc_reader_login">You</span></a>
    <small>today</small>
    <span class="gpgc-tabs">
      <button class="gpgc-tab" id="write_button">Write</button>
      <button class="gpgc-tab" id="preview_button">Preview</button>
    </span>
    <div class="gpgc-new-comment" id="write_div">
      <div class="gpgc-comment-form">
        <textarea class="gpgc-comment-form-textarea" id="new_comment_field" placeholder="Write a comment"></textarea>
      </div>
    </div>
    <div class="gpgc-new-comment gpgc-comment-contents gpgc-hidden" id="preview_div">
    </div>
    <div class="gpgc-comment-help gpgc-hidden" id="help_div">
    </div>
    <div>
      <span>
        <span>Comment token:</span>
        <input class="gpgc-oauth-token gpgc-hidden" id="oauth_token_input" size="44" type="text" name="oauth_token" oninput="authenticateUser()" onchange="authenticateUser()"></input>
        <span class="gpgc-hidden" id="oauth_token_validated"><strong>&#x2713;</strong></span>
        <button class="gpgc-hidden" id="oauth_clear_token" onclick="clearToken()"><strong>&#x2715;</strong></button>
      </span>
      <button class="gpgc-submit" id="submit_button" onclick="postComment()">Submit</button>
    </div>
  </div>
</div>

<script>
  var ShortMonthForIndex = { 0: "Jan", 1: "Feb", 2: "Mar", 3: "Apr", 4: "May", 5: "Jun", 6: "Jul", 7: "Aug", 8: "Sep", 9: "Oct", 10: "Nov", 11: "Dec" };
  var AccessToken = "";
  var IssueUrl = "";
  var CommentsUrl = "";
  var CommentsArray = [];

  var AllCommentsDiv = document.getElementById("gpgc_all_comments");
  var NoCommentsDiv = document.getElementById("gpgc_no_comments");
  var ActionsDiv = document.getElementById("gpgc_actions");
  var ShowCommentsButton = document.getElementById("show_comments_button");

  var WriteButton = document.getElementById("write_button");
  var WriteDiv = document.getElementById("write_div");
  var CommentMarkdown = document.getElementById("new_comment_field");
  var PreviewButton = document.getElementById("preview_button");
  var PreviewDiv = document.getElementById("preview_div");

  var OAuthTokenInput = document.getElementById("oauth_token_input");
  var ReaderGitHubUrl = document.getElementById("gpgc_reader_url");
  var ReaderAvatarUrl = document.getElementById("gpgc_reader_avatar");
  var ReaderLogin = document.getElementById("gpgc_reader_login");
  var TokenValidatedMark = document.getElementById("oauth_token_validated");
  var ClearTokenButton = document.getElementById("oauth_clear_token");
  var SubmitButton = document.getElementById("submit_button");

  var HelpDiv = document.getElementById("help_div");

  function initializeData() {
    retrieveToken();
    OAuthTokenInput.value = AccessToken;
  }

  function retrieveToken() {
    AccessToken = localStorage.getItem("AccessToken");
  }

  function persistToken() {
    localStorage.setItem("AccessToken", AccessToken);
  }

  function clearToken() {
    OAuthTokenInput.value = "";
    authenticateUser();
    persistToken();
  }

  function showReaderHelpMessage(message) {
    showReaderHelp(message, /* isRawHtml: */ false, "gpgc-help-message", "gpgc-help-error");
  }

  function showReaderHelpError(error, isRawHtml) {
    showReaderHelp(error, isRawHtml, "gpgc-help-error", "gpgc-help-message");
  }

  function showReaderHelp(message, isRawHtml, cssClassToAdd, cssClassToRemove) {
    if (isRawHtml) {
      HelpDiv.innerHTML = message;
    } else {
      HelpDiv.innerHTML = "<p>" + message + "</p>";
    }
    HelpDiv.classList.add(cssClassToAdd);
    HelpDiv.classList.remove(cssClassToRemove);
    showElement(HelpDiv);
  }

  function clearReaderHelp() {
    HelpDiv.innerHTML = 
    HelpDiv.classList.remove("gpgc-help-message")
    HelpDiv.classList.remove("gpgc-help-error");
    hideElement(HelpDiv);
  }

  function updateCommenterInformation(userJson) {
    ReaderGitHubUrl.href = userJson.html_url;
    ReaderAvatarUrl.src = userJson.avatar_url;
    ReaderLogin.innerHTML = userJson.login;
  }

  function onUserAuthenticated(checkAuthenticationRequest) {
    var elementsToShow = [ TokenValidatedMark, ClearTokenButton ];
    var elementsToHide = [ OAuthTokenInput ];
    var elementsToEnable = [ ClearTokenButton, SubmitButton ];
    var elementsToDisable = [  ];
    persistToken();
    updateCommenterInformation(JSON.parse(checkAuthenticationRequest.responseText));
    clearReaderHelp();
    updateElements(elementsToShow, elementsToHide, elementsToEnable, elementsToDisable);
  }

  function onUserAuthenticationError(checkAuthenticationRequest) {
    var helpErrorMessage = "Sorry, it looks like the token isn't valid. Please try again.";
    var isRawHtml = false;
{% if site.data.gpgc.enable_diagnostics %}
    helpErrorMessage = "<h3><strong>gpgc</strong> Error: Authentication Failed</h3><p>Could not authenticate OAuth token</p><p>GitHub response:</p><p><pre>" + checkAuthenticationRequest.responseText + "</pre></p>";
    isRawHtml = true;
{% endif %}
    showReaderHelpError(helpErrorMessage, isRawHtml);
    return;
  }

  function onAuthenticateUserFailed() {
    var elementsToShow = [ OAuthTokenInput ];
    var elementsToHide = [ TokenValidatedMark, ClearTokenButton ];
    var elementsToEnable = [  ];
    var elementsToDisable = [ ClearTokenButton, SubmitButton ];
    updateCommenterInformation({ login: "You", html_url: "#", avatar_url: "{{ site.baseurl }}/public/apple-touch-icon-precomposed.png" });
    showReaderHelpMessage("To leave a comment, please provide a <a href=''>GitHub OAuth token</a>.");
    updateElements(elementsToShow, elementsToHide, elementsToEnable, elementsToDisable);
  }

  function authenticateUser() {
    AccessToken = OAuthTokenInput.value;
    if (AccessToken.length == 40) {
      var userIdUrl = "https://api.github.com/user";
      getGitHubApiRequestWithCompletion(userIdUrl, AccessToken, onUserAuthenticated, onUserAuthenticationError);
    } else {
      onAuthenticateUserFailed();
    }
  }

  function onCommentPosted(postCommentRequest) {
    var commentInformation = JSON.parse(postCommentRequest.responseText);
    var newComment = formatComment(commentInformation.user.avatar_url, commentInformation.user.html_url, commentInformation.user.login, commentInformation.body_html, commentInformation.updated_at);
    AllCommentsDiv.innerHTML += newComment;
    updateCommentFormMode("write", /* reset: */ true);
    clearReaderHelp();
  }

  function onPostCommentError(postCommentRequest) {
    var helpErrorMessage = "Sorry, something surprising happened. Please try again.";
    var isRawHtml = false;
{% if site.data.gpgc.enable_diagnostics %}
    helpErrorMessage = "<h3><strong>gpgc</strong> Error: Comment Failed</h3><p>Could not create a new comment</p><p>GitHub response:</p><p><pre>" + postCommentRequest.responseText + "</pre></p>";
    isRawHtml = true;
{% endif %}
    showReaderHelpError(helpErrorMessage, isRawHtml);
  }

  function postComment() {
    if (CommentMarkdown.value.length == 0) {
      showReaderHelpError("Sorry, but your comment is empty. Please try again.");
      return;
    } else {
      clearReaderHelp();
    }

    var createCommentJson = { body: CommentMarkdown.value };
    postGitHubApiRequestWithCompletion(CommentsUrl, JSON.stringify(createCommentJson), AccessToken, onCommentPosted, onPostCommentError);
  }

  function onMarkdownRendered(renderRequest) {
    var renderedHtml = renderRequest.responseText;
    PreviewDiv.innerHTML = renderedHtml;
  }

  function onMarkdownRenderError(renderRequest) {
    var helpErrorMessage = "Sorry, something surprising happened. Please try again.";
    var isRawHtml = false;
{% if site.data.gpgc.enable_diagnostics %}
    helpErrorMessage = "<h3><strong>gpgc</strong> Error: Render Failed</h3><p>Could not render comment markdown</p><p>GitHub response:</p><p><pre>" + renderRequest.responseText + "</pre></p>";
    isRawHtml = true;
{% endif %}
    showReaderHelpError(helpErrorMessage, isRawHtml);
    return;
  }

  function renderMarkdown(markdown) {
    renderUrl = "https://api.github.com/markdown";
    markdownBundle = {text: markdown, mode: "gfm", context: "{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}"};
    postGitHubApiRequestWithCompletion(renderUrl, JSON.stringify(markdownBundle), AccessToken, onMarkdownRendered, onMarkdownRenderError);
  }

  function updateCommentFormMode(newMode, reset) {
    var elementsToShow = [];
    var elementsToHide = [];

    if (newMode === "preview") {
      WriteButton.onclick = function() { updateCommentFormMode("write", /* reset: */ false) };
      WriteButton.className = "gpgc-tab";
      PreviewButton.onclick = null;
      PreviewButton.classList.add("preview");
      elementsToHide.push(WriteDiv);
      elementsToShow.push(PreviewDiv);
      PreviewDiv.innerHTML = "";
      renderMarkdown(CommentMarkdown.value);
    } else if (newMode === "write") {
      WriteButton.onclick = null;
      WriteButton.classList.add("write");
      PreviewButton.onclick = function() { updateCommentFormMode("preview", /* reset: */ false) };
      PreviewButton.className = "gpgc-tab";
      elementsToShow.push(WriteDiv);
      elementsToHide.push(PreviewDiv);
    }

    updateElements(elementsToShow, elementsToHide, /* elementsToEnable: */ null, /* elementsToDisable: */ null);

    if (reset) {
      CommentMarkdown.value = "";
      PreviewDiv.innerHTML = "";
    }
  }

  function initializeNewCommentForm() {
    authenticateUser();
    updateCommentFormMode("write", /* reset: */ false);
  }

  function findAndCollectComments(userName, repositoryName, issueTitle) {
    var safeQuery = encodeURI(issueTitle);
    var seachQueryUrl = "https://api.github.com/search/issues?q=" + safeQuery + "+repo:" + userName + "/" + repositoryName + "+type:issue+in:title";
    getGitHubApiRequestWithCompletion(seachQueryUrl, AccessToken, onSearchComplete, onSearchError);
  }

  function onSearchComplete(searchRequest) {
    var searchResults = JSON.parse(searchRequest.responseText);
    if (searchResults.total_count === 1) {
      IssueUrl = searchResults.items[0].html_url;
      CommentsUrl = searchResults.items[0].comments_url
      getGitHubApiRequestWithCompletion(searchResults.items[0].comments_url, AccessToken, onQueryComments, onQueryCommentsError);
    }
    else {
      updateCommentsAndActions(CommentsArray);
    }
  }

  function onSearchError(searchRequest) {
{% if site.data.gpgc.enable_diagnostics %}
    var css = document.styleSheets;
    var foundCssInHead = false;
    var fetchedCss = false;
    for (var i = 0; i < css.length; i++) {
      if (css[i].href.match("ghpages-ghcomments.css")) {
        foundCssInHead = true;
        if (css[i].cssRules.length > 0) {
          fetchedCss = true;
        }
        break;
      }
    }

    var missingCssMessage = "";
    if (! foundCssInHead) {
      missingCssMessage = "<h3><strong>gpgc</strong> Error: Missing CSS</h3><p><code>ghpages-ghcomments.css</code> is not in the &lt;head&gt; element.</p><p>Add a <code>&lt;link&gt;</code> element to <code>_includes/head.hml</code>.</p>";
    }

    var css404Message = "";
    if (! fetchedCss && foundCssInHead) {
      css404Message = "<h3><strong>gpgc</strong> Error: CSS 404</h3><p>Could not retrieve <code>ghpages-ghcomments.css</code> from your site.</p><p>Check <code>_includes/head.hml</code> for typos.</p>";
    }

    var searchErrorMessage = ""
    if (searchRequest.status != 200) {
      searchErrorMessage = "<h3><strong>gpgc</strong> Error: Search Failed</h3><p>Could not search GitHub repository <strong><a href='https://www.github.com/{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}'>{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}</a></strong>.</p><p>GitHub response:</p><p><pre>" + searchRequest.responseText + "</pre></p><p>Check:<ul><li><code>repo_owner</code> in <code>_data/gpgc.yml</code> for typos.</li><li><code>repo_name</code> in <code>_data/gpgc.yml</code> for typos.</li></ul></p>";
    }

    var missingIssueMessage = "";
    if (searchResults.total_count === 0) {
      missingIssueMessage = "<h3><strong>gpgc</strong> Error: Missing Issue</h3><p>Could not find comment issue with the title <em>{{ include.post_title }}</em> in the repository <strong><a href='https://www.github.com/{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}'>{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}</a></strong>.</p><p>Check:<ul><li>for typos in the Jekyll <code>title</code> front matter for this post: <code>{{ page.path }}</code>.</li><li>that the <code>repo_name</code> in <code>_data/gpgc.yml</code> matches the repository for this site.</li><li>the terminal output from <code>git push</code> for other error messages if the git hooks are installed.</li></ul></p>";
    }

    var allMessagesHtml = missingCssMessage + css404Message + searchErrorMessage + missingIssueMessage;
    if (allMessagesHtml.length > 0) {
      allMessagesHtml += "<h3>Help</h3><p>Verify your site's configuration with the <a href='downtothewire.io/ghpages-ghcomments/setup/'>setup instructions</a> and refer to the <a href='http://downtothewire.io/ghpages-ghcomments/advanced/verbose-usage/'>verbose usage</a> for step-by-step details.</p><p>Contact <strong><a href='https://github.com/wireddown/ghpages-ghcomments/issues'>ghpages-ghcomments</a></strong> for more help.</p>";
    }

    document.body.innerHTML += "<div class='container content gpgc-all-comments'>" + allMessagesHtml + "</div>";
{% endif %}
    return;
  }

  function onQueryComments(commentRequest) {
    CommentsArray = CommentsArray.concat(JSON.parse(commentRequest.responseText));
    var commentsPages = commentRequest.getResponseHeader("Link");
    if (commentsPages) {
      var commentsLinks = commentsPages.split(",");
      for (var i = 0; i < commentsLinks.length; i++) {
        if (commentsLinks[i].search('rel="next"') > 0) {
          var linkStart = commentsLinks[i].search("<");
          var linkStop = commentsLinks[i].search(">");
          var nextLink = commentsLinks[i].substring(linkStart + 1, linkStop);
          getGitHubApiRequestWithCompletion(nextLink, /* accessToken: */ null, onQueryComments, onQueryCommentsError);
          return;
        }
      }
      updateCommentsAndActions(CommentsArray);
    }
    else {
      updateCommentsAndActions(CommentsArray);
    }
  }

  function onQueryCommentsError(commentRequest) {
    updateCommentsAndActions(CommentsArray);
  }

  function updateCommentsAndActions(allComments) {
    var elementsToShow = [];
    var elementsToHide = [];

    if (allComments.length === 0) {
      elementsToShow.push(NoCommentsDiv);
    } else {
      var allCommentsHtml = formatAllComments(CommentsArray);
      AllCommentsDiv.innerHTML = allCommentsHtml + AllCommentsDiv.innerHTML;

      var commentOrComments = allComments.length == 1 ? "Comment" : "Comments";
      ShowCommentsButton.innerHTML = "Show " + allComments.length + " " + commentOrComments;

      if (typeof {{ site.data.gpgc.use_show_action }} === "boolean" && {{ site.data.gpgc.use_show_action }}) {
        elementsToShow.push(ActionsDiv);
        elementsToHide.push(AllCommentsDiv);
      }
      else {
        elementsToHide.push(ActionsDiv);
        elementsToShow.push(AllCommentsDiv);
      }
    }

    updateElements(elementsToShow, elementsToHide, /* elementsToEnable: */ null, /* elementsToDisable: */ null);
  }

  function showAllComments(allComments) {
    var elementsToShow = [ AllCommentsDiv ];
    var elementsToHide = [ ActionsDiv, NoCommentsDiv ];
    updateElements(elementsToShow, elementsToHide, /* elementsToEnable: */ null, /* elementsToDisable: */ null);
  }

  function formatAllComments(allComments) {
    var allCommentsHtml = "";
    for (var i = 0; i < allComments.length; i++) {
      var user = allComments[i].user;
      allCommentsHtml += formatComment(user.avatar_url, user.html_url, user.login, allComments[i].body_html, allComments[i].updated_at);
    }

    return allCommentsHtml;
  }

  function formatComment(userAvatarUrl, userHtmlUrl, userLogin, commentBodyHtml, commentTimeStamp) {
    var commentDate = new Date(commentTimeStamp);
    var shortMonth = ShortMonthForIndex[commentDate.getMonth()];
    var commentHtml = "<div class='gpgc-comment'>";
    commentHtml += "<a href='" + userHtmlUrl + "'><img class='gpgc-avatar' src='" + userAvatarUrl + "' height='42' />" + userLogin + "</a> ";
    commentHtml += "<small>on " + commentDate.getDate() + " " + shortMonth + " " + commentDate.getFullYear() + "</small>";
    commentHtml += "<div class='gpgc-comment-contents'>" + commentBodyHtml + "</div>";
    commentHtml += "</div>";
    return commentHtml;
  }

  function getGitHubApiRequestWithCompletion(url, accessToken, onSuccess, onError) {
    doGitHubApiRequestWithCompletion("GET", url, null, accessToken, onSuccess, onError);
  }

  function postGitHubApiRequestWithCompletion(url, data, accessToken, onSuccess, onError) {
    doGitHubApiRequestWithCompletion("POST", url, data, accessToken, onSuccess, onError);
  }

  function doGitHubApiRequestWithCompletion(method, url, data, accessToken, onSuccess, onError) {
    var gitHubRequest = new XMLHttpRequest();
    gitHubRequest.open(method, url, /* async: */ true);

    if (accessToken != null && accessToken != "") {
      gitHubRequest.setRequestHeader("Authorization", "token " + accessToken);
    }

    gitHubRequest.setRequestHeader("Accept", "application/vnd.github.v3.html+json");
    gitHubRequest.onreadystatechange = function() { onRequestReadyStateChange(gitHubRequest, onSuccess, onError) };

    gitHubRequest.send(data);
  }

  function onRequestReadyStateChange(httpRequest, onSuccess, onError) {
    if (httpRequest.readyState != 4) { return; }
    if (httpRequest.status == 200 || httpRequest.status == 201) {
      onSuccess(httpRequest);
    } else {
      onError(httpRequest);
    }
  }

  function updateElements(elementsToShow, elementsToHide, elementsToEnable, elementsToDisable) {
    if (elementsToShow != null) showElements(elementsToShow);
    if (elementsToHide != null) hideElements(elementsToHide);
    if (elementsToEnable != null) enableElements(elementsToEnable);
    if (elementsToDisable != null) disableElements(elementsToDisable);
  }

  function updateElementVisibility(element, makeVisible) {
    if (makeVisible) {
      element.classList.remove("gpgc-hidden");
    } else {
      element.classList.add("gpgc-hidden");
    }
  }

  function showElement(element) {
    updateElementVisibility(element, /* makeVisible: */ true);
  }

  function showElements(elementList) {
    for (var i = 0; i < elementList.length; i++) {
      showElement(elementList[i]);
    }
  }

  function hideElement(element) {
    updateElementVisibility(element, /* makeVisible: */ false);
  }

  function hideElements(elementList) {
    for (var i = 0; i < elementList.length; i++) {
      hideElement(elementList[i]);
    }
  }

  function updateElementInteractivity(element, makeInteractive) {
    if (makeInteractive) {
      element.disabled = false;
    } else {
      element.disabled = true;
    }
  }

  function enableElement(elementToEnable) {
    updateElementInteractivity(elementToEnable, /* makeInteractive: */ true);
  }

  function enableElements(elementList) {
    for (var i = 0; i < elementList.length; i++) {
      enableElement(elementList[i]);
    }
  }

  function disableElement(elementToDisable) {
    updateElementInteractivity(elementToDisable, /* makeInteractive: */ false);
  }

  function disableElements(elementList) {
    for (var i = 0; i < elementList.length; i++) {
      disableElement(elementList[i]);
    }
  }

  initializeData();
  initializeNewCommentForm();
  findAndCollectComments("{{ site.data.gpgc.repo_owner }}", "{{ site.data.gpgc.repo_name }}", "{{ include.post_title }}");
</script>
