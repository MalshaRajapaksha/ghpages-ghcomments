<div class="gpgc-all-comments" id="all-comments"></div>

<div class="gpgc-actions">
  <span class="gpgc-action" id="load-comments-button"></span>
</div>

<div class="gpgc-all-comments">
  <div class="gpgc-comment">

  <a href=""><img class="gpgc-avatar" id="gpgc-user-avatar" src="" height="42" /><span id="gpgc-user-login">You</span></a> <small>today</small>

  <span class="gpgc-tabs">
    <button class="gpgc-tab" id="write-button">Write</button>
    <button class="gpgc-tab" id="preview-button">Preview</button>
  </span>

  <div class="gpgc-new-comment" id="write-div">
    <div class="gpgc-comment-form">
      <textarea class="gpgc-comment-form-textarea" id="new-comment-field" placeholder="Write a comment"></textarea>
    </div>
  </div>

  <div class="gpgc-new-comment gpgc-comment-contents" id="preview-div">
  </div>

  <div class="gpgc-comment-help" id="help-div">
  </div>

  <div>
    <span>
      <span>Comment token: </span>
      <input class="gpgc-oauth-token" id="oauth-token-input" size="44" type="text" name="oauth_token" oninput="authenticateUser()" onchange="authenticateUser()"></input>
      <span id="oauth-token-validated"><strong>&#x2713;</strong></span>
      <button id='oauth-clear-token' onclick="clearToken()"><strong>&#x2715;</strong></button>
    </span>
    <button class="gpgc-submit" id="submit-button" onclick="submitComment()">Submit</button>
  </div>

  </div>
</div>

<div class="gpgc-actions">
  <span class="gpgc-action" id="leave-comment-link"></span>
</div>

<script>
  var ShortMonthForIndex = { 0: "Jan", 1: "Feb", 2: "Mar", 3: "Apr", 4: "May", 5: "Jun", 6: "Jul", 7: "Aug", 8: "Sep", 9: "Oct", 10: "Nov", 11: "Dec" };
  var AccessToken = "";
  var IssueUrl = "";
  var CommentsUrl = "";
  var CommentsArray = [];

  function initializeData() {
    retrieveToken();
    var oauthToken = document.getElementById('oauth-token-input');
    oauthToken.value = AccessToken;
  }

  function retrieveToken() {
    AccessToken = localStorage.getItem('AccessToken');
  }

  function persistToken() {
    localStorage.setItem('AccessToken', AccessToken);
  }

  function clearToken() {
    var oauthToken = document.getElementById('oauth-token-input');
    oauthToken.value = "";
    authenticateUser();
    persistToken();
  }

  function updateControl(control_id, requestDisabled, requestVisible) {
    var control = document.getElementById(control_id);
    if (requestDisabled != null) {
      control.disabled = requestDisabled;
    }

    if (requestVisible == true) {
      control.style.display = 'unset';
    } else {
      control.style.display = 'none';
    }
  }

  function updateCommenterInformation(userJson) {
    var avatarElement = document.getElementById('gpgc-user-avatar');
    var avatarUrl = userJson.avatar_url;
    avatarElement.src = avatarUrl;
    var userLoginLink = document.getElementById('gpgc-user-login');
    userLoginLink.innerHTML = userJson.login;
  }

  function onUserAuthenticated(checkAuthenticationRequest) {
    updateControl('submit-button', false /* requestDisabled */, true /* requestVisible */);
    updateControl('oauth-token-validated', null /* requestDisabled */, true /* requestVisible */);
    updateControl('oauth-token-input', null /* requestDisabled */, false /* requestVisible */);
    updateControl('oauth-clear-token', false /* requestDisabled */, true /* requestVisible */);
    persistToken();
    updateCommenterInformation(JSON.parse(checkAuthenticationRequest.responseText));
    var helpDiv = document.getElementById('help-div');
    helpDiv.style.display = 'none';
  }

  function onAuthenticateUserFailed() {
    updateControl('submit-button', true /* requestDisabled */, true /* requestVisible */);
    updateControl('oauth-token-input', null /* requestDisabled */, true /* requestVisible */);
    updateControl('oauth-token-validated', null /* requestDisabled */, false /* requestVisible */);
    updateControl('oauth-clear-token', true /* requestDisabled */, false /* requestVisible */);
    updateCommenterInformation({avatar_url: "{{ site.baseurl }}/public/apple-touch-icon-precomposed.png", login: "You"});
    var helpDiv = document.getElementById('help-div');
    helpDiv.innerHTML = "<p>To leave a comment, please provide a <a href=''>GitHub OAuth token</a>.</p>";
    helpDiv.style.display = 'block';
  }

  function authenticateUser() {
    var oauthToken = document.getElementById('oauth-token-input');
    AccessToken = oauthToken.value;
    if (AccessToken.length == 40) {
      var userIdUrl = "https://api.github.com/user";
      getGitHubApiRequestWithCompletion(userIdUrl, AccessToken, onUserAuthenticated);
    } else {
      onAuthenticateUserFailed();
    }
  }

  function onCommentPosted(createCommentRequest) {
    var commentInformation = JSON.parse(createCommentRequest.responseText);
    var newComment = formatComment(commentInformation.user.avatar_url, commentInformation.user.html_url, commentInformation.user.login, commentInformation.body_html, commentInformation.updated_at);
    document.getElementById("all-comments").innerHTML += newComment;
    updateCommentFormMode("write", true /* reset */);
  }

  function submitComment() {
    var commentMarkdown = document.getElementById('new-comment-field').value;
    var helpDiv = document.getElementById('help-div');
    if (commentMarkdown.length == 0) {
      helpDiv.innerHTML = '<p>Sorry, but your comment is empty. Please try again.</p>';
      helpDiv.style.display = 'block';
      return;
    } else {
      helpDiv.style.display = 'none';
    }

    var createCommentJson = { body: commentMarkdown };
    postGitHubApiRequestWithCompletion(CommentsUrl, JSON.stringify(createCommentJson), AccessToken, onCommentPosted);
  }

  function onMarkdownRendered(renderRequest) {
    var renderedHtml = renderRequest.responseText;
{% if site.data.gpgc.enable_diagnostics %}
    if (renderRequest.status != 200) {
      renderedHtml = '<h3><strong>gpgc</strong> Error: Render Failed</h3><p>Could not render comment markdown</p><p>GitHub response:</p><p><pre>' + renderRequest.responseText + '</pre></p>';
    }
{% endif %}
    var previewDiv = document.getElementById('preview-div');
    previewDiv.innerHTML = renderedHtml;
  }

  function renderMarkdown(markdown) {
    renderUrl = "https://api.github.com/markdown";
    markdownBundle = {text: markdown, mode: "gfm", context: "{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}"};
    postGitHubApiRequestWithCompletion(renderUrl, JSON.stringify(markdownBundle), null /* access_token */, onMarkdownRendered);
  }

  function updateCommentFormMode(newMode, reset) {
    var writeButton = document.getElementById('write-button');
    var writeDiv = document.getElementById('write-div');
    var previewButton = document.getElementById('preview-button');
    var previewDiv = document.getElementById('preview-div');
    if (newMode === "preview") {
      writeButton.onclick = function() { updateCommentFormMode("write", false /* reset */) };
      writeButton.className = "gpgc-tab";
      writeDiv.style.display = "none";
      previewButton.onclick = null;
      previewButton.className += " preview";
      previewDiv.style.display = "block";
      var commentMarkdown = document.getElementById('new-comment-field').value;
      previewDiv.innerHTML = "";
      renderMarkdown(commentMarkdown);
    } else if (newMode === "write") {
      writeButton.onclick = null;
      writeButton.className += " write";
      writeDiv.style.display = "block";
      previewButton.onclick = function() { updateCommentFormMode("preview", false /* reset */) };
      previewButton.className = "gpgc-tab";
      previewDiv.style.display = "none";
    } else {
      alert("Unknown comment form mode: " + newMode);
    }

    if (reset) {
      document.getElementById('new-comment-field').value = "";
      previewDiv.innerHTML = "";
    }
  }

  function initializeNewCommentForm() {
    authenticateUser();
    updateCommentFormMode("write", false /* reset */);
  }

  function findAndCollectComments(userName, repositoryName, issueTitle) {
    var safeQuery = encodeURI(issueTitle);
    var seachQueryUrl = "https://api.github.com/search/issues?q=" + safeQuery + "+repo:" + userName + "/" + repositoryName + "+type:issue+in:title";
    getGitHubApiRequestWithCompletion(seachQueryUrl, null /* access_token */, onSearchComplete);
  }

  function onSearchComplete(searchRequest) {
    var searchResults = JSON.parse(searchRequest.responseText);
{% if site.data.gpgc.enable_diagnostics %}
    var css = document.styleSheets;
    var foundCssInHead = false;
    var fetchedCss = false;
    for (var i = 0; i < css.length; i++) {
      if (css[i].href.match("ghpages-ghcomments.css")) {
        foundCssInHead = true;
        if (css[i].cssRules.length > 0) {
          fetchedCss = true;
        }
        break;
      }
    }

    var missingCssMessage = "";
    if (! foundCssInHead) {
      missingCssMessage = '<h3><strong>gpgc</strong> Error: Missing CSS</h3><p><code>ghpages-ghcomments.css</code> is not in the &lt;head&gt; element.</p><p>Add a <code>&lt;link&gt;</code> element to <code>_includes/head.hml</code>.</p>';
    }

    var css404Message = "";
    if (! fetchedCss && foundCssInHead) {
      css404Message = '<h3><strong>gpgc</strong> Error: CSS 404</h3><p>Could not retrieve <code>ghpages-ghcomments.css</code> from your site.</p><p>Check <code>_includes/head.hml</code> for typos.</p>';
    }

    var searchErrorMessage = ""
    if (searchRequest.status != 200) {
      searchErrorMessage = '<h3><strong>gpgc</strong> Error: Search Failed</h3><p>Could not search GitHub repository <strong><a href="https://www.github.com/{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}">{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}</a></strong>.</p><p>GitHub response:</p><p><pre>' + searchRequest.responseText + '</pre></p><p>Check:<ul><li><code>repo_owner</code> in <code>_data/gpgc.yml</code> for typos.</li><li><code>repo_name</code> in <code>_data/gpgc.yml</code> for typos.</li></ul></p>';
    }

    var missingIssueMessage = "";
    if (searchResults.total_count === 0) {
      missingIssueMessage = '<h3><strong>gpgc</strong> Error: Missing Issue</h3><p>Could not find comment issue with the title <em>{{ include.post_title }}</em> in the repository <strong><a href="https://www.github.com/{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}">{{ site.data.gpgc.repo_owner }}/{{ site.data.gpgc.repo_name }}</a></strong>.</p><p>Check:<ul><li>for typos in the Jekyll <code>title</code> front matter for this post: <code>{{ page.path }}</code>.</li><li>that the <code>repo_name</code> in <code>_data/gpgc.yml</code> matches the repository for this site.</li><li>the terminal output from <code>git push</code> for other error messages if the git hooks are installed.</li></ul></p>';
    }

    var allMessagesHtml = missingCssMessage + css404Message + searchErrorMessage + missingIssueMessage;
    if (allMessagesHtml.length > 0) {
      allMessagesHtml += '<h3>Help</h3><p>Verify your site\'s configuration with the <a href="downtothewire.io/ghpages-ghcomments/setup/">setup instructions</a> and refer to the <a href="http://downtothewire.io/ghpages-ghcomments/advanced/verbose-usage/">verbose usage</a> for step-by-step details.</p><p>Contact <strong><a href="https://github.com/wireddown/ghpages-ghcomments/issues">ghpages-ghcomments</a></strong> for more help.</p>';
    }

    document.body.innerHTML += '<div class="container content gpgc-all-comments">' + allMessagesHtml + '</div>';
{% endif %}
    if (searchResults.total_count === 1) {
      IssueUrl = searchResults.items[0].html_url;
      CommentsUrl = searchResults.items[0].comments_url
      getGitHubApiRequestWithCompletion(searchResults.items[0].comments_url, null /* access_token */, onCommentsUpdated);
    }
    else {
      updateCommentActions(CommentsArray);
    }
  }

  function onCommentsUpdated(commentRequest)
  {
    CommentsArray = CommentsArray.concat(JSON.parse(commentRequest.responseText));
    var commentsPages = commentRequest.getResponseHeader("Link");
    if (commentsPages) {
      var commentsLinks = commentsPages.split(",");
      for (var i = 0; i < commentsLinks.length; i++) {
        if (commentsLinks[i].search('rel="next"') > 0) {
          var linkStart = commentsLinks[i].search("<");
          var linkStop = commentsLinks[i].search(">");
          var nextLink = commentsLinks[i].substring(linkStart + 1, linkStop);
          getGitHubApiRequestWithCompletion(nextLink, null /* access_token */, onCommentsUpdated);
          return;
        }
      }
      updateCommentActions(CommentsArray);
    }
    else {
      updateCommentActions(CommentsArray);
    }
  }

  function updateCommentActions(allComments)
  {
    var allCommentsHtml = "";
    var loadCommentsHtml = "";
    var leaveCommentUrl = "";

    if (typeof {{ site.data.gpgc.use_show_action }} === 'boolean' && {{ site.data.gpgc.use_show_action }}) {
      var commentOrComments = allComments.length == 1 ? "Comment" : "Comments";
      loadCommentsHtml = '<button class="gpgc-show" onclick="presentAllComments(CommentsArray)">Show ' + allComments.length + ' ' + commentOrComments + '</button>';
    }
    else {
      allCommentsHtml = formatAllComments(CommentsArray);
    }

    if (allComments.length === 0) {
      allCommentsHtml = '<p class="gpgc-no-comments">No comments</p>';
      loadCommentsHtml = "";
      leaveCommentUrl = IssueUrl;
    }
    else {
      leaveCommentUrl = allComments[allComments.length - 1].html_url;
    }

    var leaveCommentsHtml = '<a class="gpgc-leave" href="' + leaveCommentUrl + '" target="_blank">Leave a comment</a>';
    updateCommentDivs(allCommentsHtml, loadCommentsHtml, leaveCommentsHtml);
  }

  function presentAllComments(allComments) {
    allCommentsHtml = formatAllComments(allComments);
    updateCommentDivs(allCommentsHtml, "", null);
  }

  function formatAllComments(allComments) {
    var allCommentsHtml = '';
    for (var i = 0; i < allComments.length; i++) {
      var user = allComments[i].user;
      allCommentsHtml += formatComment(user.avatar_url, user.html_url, user.login, allComments[i].body_html, allComments[i].updated_at);
    }

    return allCommentsHtml;
  }

  function formatComment(userAvatarUrl, userHtmlUrl, userLogin, commentBodyHtml, commentTimeStamp) {
    var commentDate = new Date(commentTimeStamp);
    var shortMonth = ShortMonthForIndex[commentDate.getMonth()];
    var commentHtml = '<div class="gpgc-comment">';
    commentHtml += '<a href="' + userHtmlUrl + '"><img class="gpgc-avatar" src="' + userAvatarUrl + '" height="42" />' + userLogin + '</a> ';
    commentHtml += '<small>on ' + commentDate.getDate() + ' ' + shortMonth + ' ' + commentDate.getFullYear() + '</small>';
    commentHtml += '<div class="gpgc-comment-contents">' + commentBodyHtml + '</div>';
    commentHtml += '</div>';
    return commentHtml;
  }

  function getGitHubApiRequestWithCompletion(url, access_token, completion)
  {
    doGitHubApiRequestWithCompletion("GET", url, null, access_token, completion);
  }

  function postGitHubApiRequestWithCompletion(url, data, access_token, completion)
  {
    doGitHubApiRequestWithCompletion("POST", url, data, access_token, completion);
  }

  function doGitHubApiRequestWithCompletion(method, url, data, access_token, completion)
  {
    var gitHubRequest = new XMLHttpRequest();
    gitHubRequest.open(method, url, true);

    if (access_token) {
      gitHubRequest.setRequestHeader('Authorization', 'token ' + access_token);
    }

    gitHubRequest.setRequestHeader("Accept", "application/vnd.github.v3.html+json");
    gitHubRequest.onreadystatechange = function() { OnReadyStateChange(gitHubRequest, completion) };

    gitHubRequest.send(data);
  }

  function OnReadyStateChange(httpRequest, completion)
  {
    if (httpRequest.readyState != 4) { return; }
    if (httpRequest.status == 200 || httpRequest.status == 201) {
      completion(httpRequest);
    } else {
      {% if site.data.gpgc.enable_diagnostics %} completion(httpRequest); {% endif %}
      return;
    }
  }

  function updateCommentDivs(allCommentsHtml, loadCommentsHtml, leaveCommentsHtml)
  {
    if (allCommentsHtml != null) document.getElementById("all-comments").innerHTML = allCommentsHtml + document.getElementById("all-comments").innerHTML;
    if (loadCommentsHtml != null) document.getElementById("load-comments-button").innerHTML = loadCommentsHtml;
    if (leaveCommentsHtml != null) document.getElementById("leave-comment-link").innerHTML = leaveCommentsHtml;
  }

  initializeData();
  initializeNewCommentForm();
  findAndCollectComments("{{ site.data.gpgc.repo_owner }}", "{{ site.data.gpgc.repo_name }}", "{{ include.post_title }}");
</script>
